// AUTOGENERATED DO NOT EDIT!
// This file contains Directus types that are accessible to users through the API.
export interface paths {
    "/assets/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Asset
         * @description Image typed files can be dynamically resized and transformed to fit any need.
         */
        get: operations["getAsset"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Retrieve a Temporary Access Token
         * @description Retrieve a Temporary Access Token
         */
        post: operations["login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Refresh Token
         * @description Refresh a Temporary Access Token.
         */
        post: operations["refresh"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Log Out
         * @description Log Out
         */
        post: operations["logout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/password/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request a Password Reset
         * @description Request a reset password email to be send.
         */
        post: operations["passwordRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/password/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset a Password
         * @description The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
         */
        post: operations["passwordReset"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/oauth": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List OAuth Providers
         * @description List configured OAuth providers.
         */
        get: operations["oauth"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/oauth/{provider}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Authenticated using an OAuth provider
         * @description Start OAuth flow using the specified provider
         */
        get: operations["oauthProvider"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/server/info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * System Info
         * @description Perform a system status check and return the options.
         */
        get: operations["serverInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/server/ping": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Ping
         * @description Ping, pong. Ping.. pong.
         */
        get: operations["ping"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utils/hash/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Hash a string
         * @description Generate a hash for a given string.
         */
        post: operations["hash-generate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utils/hash/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Hash a string
         * @description Generate a hash for a given string.
         */
        post: operations["hash-verify"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utils/sort/{collection}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Sort Items
         * @description Re-sort items in collection based on start and to value of item
         */
        post: operations["sort"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utils/import/{collection}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import Items
         * @description Import multiple records from a JSON or CSV file into a collection.
         */
        post: operations["import"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utils/export/{collection}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Export Items
         * @description Export a larger data set to a file in the File Library
         */
        post: operations["export"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utils/cache/clear": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Clear Cache
         * @description Resets both the data and schema cache of Directus.
         */
        post: operations["clear-cache"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/utils/random/string": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Random String
         * @description Returns a random string of given length.
         */
        get: operations["random"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Roles
         * @description List the roles.
         */
        get: operations["getRoles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Role
         * @description Retrieve a single role by unique identifier.
         */
        get: operations["getRole"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Folders
         * @description List the folders.
         */
        get: operations["getFolders"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Folder
         * @description Retrieve a single folder by unique identifier.
         */
        get: operations["getFolder"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Files
         * @description List the files.
         */
        get: operations["getFiles"];
        put?: never;
        /**
         * Create a File
         * @description Create a new file
         */
        post: operations["createFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/files/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Files
         * @description Retrieve a single file by unique identifier.
         */
        get: operations["getFile"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/presets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Presets
         * @description List the presets.
         */
        get: operations["getPresets"];
        put?: never;
        /**
         * Create a Preset
         * @description Create a new preset.
         */
        post: operations["createPreset"];
        /**
         * Delete Multiple Presets
         * @description Delete multiple existing presets.
         */
        delete: operations["deletePresets"];
        options?: never;
        head?: never;
        /**
         * Update Multiple Presets
         * @description Update multiple presets at the same time.
         */
        patch: operations["updatePresets"];
        trace?: never;
    };
    "/presets/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Preset
         * @description Retrieve a single preset by unique identifier.
         */
        get: operations["getPreset"];
        put?: never;
        post?: never;
        /**
         * Delete a Preset
         * @description Delete an existing preset.
         */
        delete: operations["deletePreset"];
        options?: never;
        head?: never;
        /**
         * Update a Preset
         * @description Update an existing preset.
         */
        patch: operations["updatePreset"];
        trace?: never;
    };
    "/activity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Activity Actions
         * @description Returns a list of activity actions.
         */
        get: operations["getActivities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/activity/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Activity Action
         * @description Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
         */
        get: operations["getActivity"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/relations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Relations
         * @description List the relations.
         */
        get: operations["getRelations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/relations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Relation
         * @description Retrieve a single relation by unique identifier.
         */
        get: operations["getRelation"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve Settings
         * @description List the settings.
         */
        get: operations["getSettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/fields": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List All Fields
         * @description Returns a list of the fields available in the project.
         */
        get: operations["getFields"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/fields/{collection}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Fields in Collection
         * @description Returns a list of the fields available in the given collection.
         */
        get: operations["getCollectionFields"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/fields/{collection}/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Field
         * @description Retrieves the details of a single field in a given collection.
         */
        get: operations["getCollectionField"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Users
         * @description List the users.
         */
        get: operations["getUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Multiple Users
         * @description Update multiple users at the same time.
         */
        patch: operations["updateUsers"];
        trace?: never;
    };
    "/users/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a User
         * @description Retrieve a single user by unique identifier.
         */
        get: operations["getUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update a User
         * @description Update an existing user
         */
        patch: operations["updateUser"];
        trace?: never;
    };
    "/users/invite": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/invite/accept": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve Current User
         * @description Retrieve the currently authenticated user.
         */
        get: operations["getMe"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Current User
         * @description Update the currently authenticated user.
         */
        patch: operations["updateMe"];
        trace?: never;
    };
    "/users/me/track/page": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Last Page
         * @description Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
         */
        patch: operations["updateLastUsedPageMe"];
        trace?: never;
    };
    "/users/me/tfa/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/me/tfa/disable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Collections
         * @description Returns a list of the collections available in the project.
         */
        get: operations["getCollections"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collections/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Collection
         * @description Retrieves the details of a single collection.
         */
        get: operations["getCollection"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Comments
         * @description List the comments.
         */
        get: operations["getComments"];
        put?: never;
        /**
         * Create a Comment
         * @description Create a new comment.
         */
        post: operations["createComment"];
        /**
         * Delete Multiple Comments
         * @description Delete multiple existing comments.
         */
        delete: operations["deleteComments"];
        options?: never;
        head?: never;
        /**
         * Update Multiple Comments
         * @description Update multiple comments at the same time.
         */
        patch: operations["updateComments"];
        trace?: never;
    };
    "/comments/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a Comment
         * @description Retrieve a single comment by unique identifier.
         */
        get: operations["getComment"];
        put?: never;
        post?: never;
        /**
         * Delete a Comment
         * @description Delete an existing comment.
         */
        delete: operations["deleteComment"];
        options?: never;
        head?: never;
        /**
         * Update a Comment
         * @description Update an existing comment.
         */
        patch: operations["updateComment"];
        trace?: never;
    };
    "/items/art_authors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the art_authors items.
         */
        get: operations["readItemsArtAuthors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/art_authors/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single art_authors item by unique identifier.
         */
        get: operations["readSingleItemsArtAuthors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/chat": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the chat items.
         */
        get: operations["readItemsChat"];
        put?: never;
        /**
         * Create an Item
         * @description Create a new chat item.
         */
        post: operations["createItemsChat"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/chat/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single chat item by unique identifier.
         */
        get: operations["readSingleItemsChat"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/users_extra": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the users_extra items.
         */
        get: operations["readItemsUsersExtra"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/users_extra/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single users_extra item by unique identifier.
         */
        get: operations["readSingleItemsUsersExtra"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/art_articles_translations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the art_articles_translations items.
         */
        get: operations["readItemsArtArticlesTranslations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/art_articles_translations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single art_articles_translations item by unique identifier.
         */
        get: operations["readSingleItemsArtArticlesTranslations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/art_articles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the art_articles items.
         */
        get: operations["readItemsArtArticles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/art_articles/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single art_articles item by unique identifier.
         */
        get: operations["readSingleItemsArtArticles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/block_image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the block_image items.
         */
        get: operations["readItemsBlockImage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/block_image/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single block_image item by unique identifier.
         */
        get: operations["readSingleItemsBlockImage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/block_markdown": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the block_markdown items.
         */
        get: operations["readItemsBlockMarkdown"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/block_markdown/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single block_markdown item by unique identifier.
         */
        get: operations["readSingleItemsBlockMarkdown"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/art_articles_blocks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the art_articles_blocks items.
         */
        get: operations["readItemsArtArticlesBlocks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/art_articles_blocks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single art_articles_blocks item by unique identifier.
         */
        get: operations["readSingleItemsArtArticlesBlocks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/art_articles_art_authors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Items
         * @description List the art_articles_art_authors items.
         */
        get: operations["readItemsArtArticlesArtAuthors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/items/art_articles_art_authors/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an Item
         * @description Retrieve a single art_articles_art_authors item by unique identifier.
         */
        get: operations["readSingleItemsArtArticlesArtAuthors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Files: {
            /**
             * @description Unique identifier for the file.
             * @example 8cbb43fe-4cdf-4991-8352-c461779cec02
             */
            id: string;
            /**
             * @description Where the file is stored. Either `local` for the local filesystem or the name of the storage adapter (for example `s3`).
             * @example local
             */
            storage: string;
            /**
             * @description Name of the file on disk. By default, Directus uses a random hash for the filename.
             * @example a88c3b72-ac58-5436-a4ec-b2858531333a.jpg
             */
            filename_disk: string;
            /**
             * @description How you want to the file to be named when it's being downloaded.
             * @example avatar.jpg
             */
            filename_download: string;
            /**
             * @description Title for the file. Is extracted from the filename on upload, but can be edited by the user.
             * @example User Avatar
             */
            title: string;
            /**
             * @description MIME type of the file.
             * @example image/jpeg
             */
            type: string;
            /**
             * @description Virtual folder where this file resides in.
             * @example null
             */
            folder?: (string | components["schemas"]["Folders"]) | null;
            /**
             * @description Who uploaded the file.
             * @example 63716273-0f29-4648-8a2a-2af2948f6f78
             */
            uploaded_by: string | components["schemas"]["Users"];
            /**
             * Format: date-time
             * @description When the file was created.
             * @example 2019-12-03T00:10:15+00:00
             */
            created_on: string;
            modified_by?: (string | components["schemas"]["Users"]) | null;
            /** Format: timestamp */
            modified_on: string;
            /**
             * @description Character set of the file.
             * @example binary
             */
            charset?: string | null;
            /**
             * @description Size of the file in bytes.
             * @example 137862
             */
            filesize: number;
            /**
             * @description Width of the file in pixels. Only applies to images.
             * @example 800
             */
            width?: number | null;
            /**
             * @description Height of the file in pixels. Only applies to images.
             * @example 838
             */
            height?: number | null;
            /**
             * @description Duration of the file in seconds. Only applies to audio and video.
             * @example 0
             */
            duration?: number | null;
            /**
             * @description Where the file was embedded from.
             * @example null
             */
            embed?: string | null;
            /** @description Description for the file. */
            description?: string | null;
            /** @description Where the file was created. Is automatically populated based on Exif data for images. */
            location?: string | null;
            /** @description Tags for the file. Is automatically populated based on Exif data for images. */
            tags?: string[] | null;
            /** @description IPTC, Exif, and ICC metadata extracted from file */
            metadata?: Record<string, never> | null;
            focal_point_x?: number | null;
            focal_point_y?: number | null;
            tus_id?: string | null;
            tus_data?: unknown;
            /**
             * Format: date-time
             * @description When the file was last uploaded/replaced.
             * @example 2019-12-03T00:10:15+00:00
             */
            uploaded_on: string;
        };
        Folders: {
            /**
             * @description Unique identifier for the folder.
             * @example 0cf0e03d-4364-45df-b77b-ca61f61869d2
             */
            id: string;
            /**
             * @description Name of the folder.
             * @example New York
             */
            name: string;
            /**
             * @description Unique identifier of the parent folder. This allows for nested folders.
             * @example null
             */
            parent?: (string | components["schemas"]["Folders"]) | null;
        };
        Roles: {
            /**
             * @description Unique identifier for the role.
             * @example 2f24211d-d928-469a-aea3-3c8f53d4e426
             */
            id: string;
            /**
             * @description Name of the role.
             * @example Administrator
             */
            name: string;
            /**
             * @description The role's icon.
             * @example verified_user
             */
            icon: string;
            /**
             * @description Description of the role.
             * @example Admins have access to all managed data within the system by default
             */
            description?: string | null;
            /** @description $t:field_options.directus_roles.parent_note */
            parent?: (string | components["schemas"]["Roles"]) | null;
            /** @description $t:field_options.directus_roles.children_note */
            children?: (string | components["schemas"]["Roles"])[] | null;
            policies?: string | null;
            users?: (string | components["schemas"]["Users"])[] | null;
        };
        Users: {
            /**
             * @description Unique identifier for the user.
             * @example 63716273-0f29-4648-8a2a-2af2948f6f78
             */
            id: string;
            /**
             * @description First name of the user.
             * @example Admin
             */
            first_name: string;
            /**
             * @description Last name of the user.
             * @example User
             */
            last_name: string;
            /**
             * Format: email
             * @description Unique email address for the user.
             * @example admin@example.com
             */
            email: string;
            /** @description Password of the user. */
            password: string;
            /**
             * @description The user's location.
             * @example null
             */
            location?: string | null;
            /**
             * @description The user's title.
             * @example null
             */
            title?: string | null;
            /**
             * @description The user's description.
             * @example null
             */
            description?: string | null;
            /**
             * @description The user's tags.
             * @example null
             */
            tags?: string[] | null;
            /**
             * @description The user's avatar.
             * @example null
             */
            avatar?: (string | components["schemas"]["Files"]) | null;
            /**
             * @description The user's language used in Directus.
             * @example en-US
             */
            language: string;
            /**
             * @description The 2FA secret string that's used to generate one time passwords.
             * @example null
             */
            tfa_secret?: string | null;
            /**
             * @description Status of the user.
             * @example active
             * @enum {string}
             */
            status: "active" | "invited" | "draft" | "suspended" | "deleted";
            /**
             * @description Unique identifier of the role of this user.
             * @example 2f24211d-d928-469a-aea3-3c8f53d4e426
             */
            role: string | components["schemas"]["Roles"];
            /**
             * Format: date-time
             * @description When this user used the API last.
             * @example 2020-05-31T14:32:37Z
             */
            last_access?: string | null;
            /**
             * @description Last page that the user was on.
             * @example /my-project/settings/collections/a
             */
            last_page?: string | null;
            provider: string;
            external_identifier?: string | null;
            email_notifications?: boolean | null;
            appearance?: string | null;
            theme_dark?: string | null;
            theme_light?: string | null;
            theme_light_overrides?: unknown;
            theme_dark_overrides?: unknown;
            policies?: string | null;
        };
        Query: {
            /**
             * @description Control what fields are being returned in the object.
             * @example [
             *       "*",
             *       "*.*"
             *     ]
             */
            fields: string[];
            /** @example {
             *       "<field>": {
             *         "<operator>": "<value>"
             *       }
             *     } */
            filter: Record<string, never>;
            /** @description Filter by items that contain the given search query in one of their fields. */
            search: string;
            /**
             * @description How to sort the returned items.
             * @example [
             *       "-date_created"
             *     ]
             */
            sort: string[];
            /** @description Set the maximum number of items that will be returned */
            limit: number;
            /** @description How many items to skip when fetching data. */
            offset: number;
            /** @description Cursor for use in pagination. Often used in combination with limit. */
            page: number;
            /**
             * @description Deep allows you to set any of the other query parameters on a nested relational dataset.
             * @example {
             *       "related_articles": {
             *         "_limit": 3
             *       }
             *     }
             */
            deep: Record<string, never>;
        };
        "x-metadata": {
            /** @description Returns the total item count of the collection you're querying. */
            total_count: number;
            /** @description Returns the item count of the collection you're querying, taking the current filter/search parameters into account. */
            filter_count: number;
        };
        Presets: {
            /**
             * @description Unique identifier for this single collection preset.
             * @example 155
             */
            id: number;
            /** @description Name for the bookmark. If this is set, the preset will be considered a bookmark. */
            bookmark?: string | null;
            /**
             * @description The unique identifier of the user to whom this collection preset applies.
             * @example 63716273-0f29-4648-8a2a-2af2948f6f78
             */
            user?: (string | components["schemas"]["Users"]) | null;
            /**
             * @description The unique identifier of a role in the platform. If `user` is null, this will be used to apply the collection preset or bookmark for all users in the role.
             * @example 50419801-0f30-8644-2b3c-9bc2d980d0a0
             */
            role?: (string | components["schemas"]["Roles"]) | null;
            /**
             * @description What collection this collection preset is used for.
             * @example articles
             */
            collection: string | components["schemas"]["Collections"];
            /** @description Search query. */
            search?: string | null;
            /**
             * @description Key of the layout that is used.
             * @example null
             */
            layout: string;
            /**
             * @description Layout query that's saved per layout type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters.
             * @example {
             *       "cards": {
             *         "sort": "-published_on"
             *       }
             *     }
             */
            layout_query?: unknown;
            /**
             * @description Options of the views. The properties in here are controlled by the layout.
             * @example {
             *       "cards": {
             *         "icon": "account_circle",
             *         "title": "{{ first_name }} {{ last_name }}",
             *         "subtitle": "{{ title }}",
             *         "size": 3
             *       }
             *     }
             */
            layout_options?: unknown;
            refresh_interval?: number | null;
            filter?: unknown;
            icon?: string | null;
            color?: string | null;
        };
        Activity: {
            /**
             * @description Unique identifier for the object.
             * @example 2
             */
            id: number;
            /**
             * @description Action that was performed.
             * @example update
             * @enum {string}
             */
            action: "create" | "update" | "delete" | "login";
            /** @description The user who performed this action. */
            user?: (string | components["schemas"]["Users"]) | null;
            /**
             * Format: date-time
             * @description When the action happened.
             * @example 2019-12-05T22:52:09Z
             */
            timestamp: string;
            /**
             * @description The IP address of the user at the time the action took place.
             * @example 127.0.0.1
             */
            ip: string;
            /**
             * @description User agent string of the browser the user used when the action took place.
             * @example Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_1) AppleWebKit/537.36 (KHTML,like Gecko) Chrome/78.0.3904.108 Safari/537.36
             */
            user_agent: string;
            /** @description Collection identifier in which the item resides. */
            collection: string | components["schemas"]["Collections"];
            /**
             * @description Unique identifier for the item the action applied to. This is always a string, even for integer primary keys.
             * @example 328
             */
            item: string;
            /**
             * @description Origin of the request when the action took place.
             * @example https://directus.io
             */
            origin: string;
            revisions?: string | null;
        };
        Relations: {
            /**
             * @description Unique identifier for the relation.
             * @example 1
             */
            id: number;
            /**
             * @description Collection that has the field that holds the foreign key.
             * @example directus_activity
             */
            many_collection: string;
            /**
             * @description Foreign key. Field that holds the primary key of the related collection.
             * @example user
             */
            many_field: string;
            /**
             * @description Collection on the _one_ side of the relationship.
             * @example directus_users
             */
            one_collection: string;
            /**
             * @description Alias column that serves as the _one_ side of the relationship.
             * @example null
             */
            one_field?: string | null;
            one_collection_field?: string | null;
            one_allowed_collections?: string[] | null;
            /**
             * @description Field on the junction table that holds the many field of the related relation.
             * @example null
             */
            junction_field?: string | null;
            sort_field?: string | null;
            one_deselect_action: string;
        };
        Settings: {
            /**
             * @description Unique identifier for the setting.
             * @example 1
             */
            id: number;
            /**
             * @description The name of the project.
             * @example Directus
             */
            project_name: string;
            /**
             * @description The url of the project.
             * @example null
             */
            project_url?: string | null;
            /**
             * @description The brand color of the project.
             * @example null
             */
            project_color?: string | null;
            /**
             * @description The logo of the project.
             * @example null
             */
            project_logo?: string | null;
            /**
             * @description The foreground of the project.
             * @example null
             */
            public_foreground?: string | null;
            /**
             * @description The background of the project.
             * @example null
             */
            public_background?: {
                id?: string;
                type?: string;
            } | null;
            /**
             * @description Note rendered on the public pages of the app.
             * @example null
             */
            public_note?: string | null;
            /**
             * @description Allowed authentication login attempts before the user's status is set to blocked.
             * @example 25
             */
            auth_login_attempts: number;
            /** @description Authentication password policy. */
            auth_password_policy?: string | null;
            /**
             * @description What transformations are allowed in the assets endpoint.
             * @example all
             * @enum {string|null}
             */
            storage_asset_transform?: "all" | "none" | "presets" | null;
            /**
             * @description Array of allowed
             * @example null
             */
            storage_asset_presets?: {
                /** @description Key for the asset. Used in the assets endpoint. */
                key?: string;
                /**
                 * @description Whether to crop the thumbnail to match the size, or maintain the aspect ratio.
                 * @enum {string}
                 */
                fit?: "cover" | "contain" | "inside" | "outside";
                /** @description Width of the thumbnail. */
                width?: number;
                /** @description Height of the thumbnail. */
                height?: number;
                /** @description No image upscale */
                withoutEnlargement?: boolean;
                /** @description Quality of the compression used. */
                quality?: number;
                /**
                 * @description Reformat output image
                 * @enum {string}
                 */
                format?: "" | "jpeg" | "png" | "webp" | "tiff" | "avif";
                /** @description Additional transformations to apply */
                transforms?: {
                    /** @description The Sharp method name */
                    method?: string;
                    /** @description A list of arguments to pass to the Sharp method */
                    arguments?: {
                        /** @description A JSON representation of the argument value */
                        argument?: string;
                    }[] | null;
                }[] | null;
            }[] | null;
            custom_css?: string | null;
            /**
             * Format: uuid
             * @description Default folder to place files
             */
            storage_default_folder: string;
            basemaps?: unknown;
            mapbox_key?: string | null;
            module_bar?: unknown;
            project_descriptor?: string | null;
            default_language: string;
            custom_aspect_ratios?: unknown;
            /** @description $t:field_options.directus_settings.project_favicon_note */
            public_favicon?: (string | components["schemas"]["Files"]) | null;
            default_appearance: string;
            default_theme_light?: string | null;
            theme_light_overrides?: unknown;
            default_theme_dark?: string | null;
            theme_dark_overrides?: unknown;
            report_error_url?: string | null;
            report_bug_url?: string | null;
            report_feature_url?: string | null;
            /** @description $t:fields.directus_settings.public_registration_note */
            public_registration: boolean;
            /** @description $t:fields.directus_settings.public_registration_verify_email_note */
            public_registration_verify_email: boolean;
            /** @description $t:fields.directus_settings.public_registration_role_note */
            public_registration_role?: (string | components["schemas"]["Roles"]) | null;
            /** @description $t:fields.directus_settings.public_registration_email_filter_note */
            public_registration_email_filter?: unknown;
            visual_editor_urls?: unknown;
        };
        Fields: {
            id: number;
            /**
             * @description Unique name of the collection this field is in.
             * @example about_us
             */
            collection: string;
            /**
             * @description Unique name of the field. Field name is unique within the collection.
             * @example id
             */
            field: string;
            special?: string[] | null;
            interface?: string | null;
            options?: unknown;
            display?: string | null;
            display_options?: unknown;
            readonly: boolean;
            hidden: boolean;
            sort?: number | null;
            width?: string | null;
            translations?: unknown;
            note?: string | null;
            conditions?: unknown;
            required?: boolean | null;
            group?: (number | components["schemas"]["Fields"]) | null;
            validation?: unknown;
            validation_message?: string | null;
        };
        Collections: {
            /**
             * @description The collection key.
             * @example customers
             */
            collection: string;
            icon?: string | null;
            note?: string | null;
            display_template?: string | null;
            hidden: boolean;
            singleton: boolean;
            translations?: unknown;
            archive_field?: string | null;
            archive_app_filter: boolean;
            archive_value?: string | null;
            unarchive_value?: string | null;
            sort_field?: string | null;
            accountability?: string | null;
            color?: string | null;
            item_duplication_fields?: unknown;
            sort?: number | null;
            group?: (string | components["schemas"]["Collections"]) | null;
            collapse: string;
            preview_url?: string | null;
            versioning: boolean;
        };
        Comments: {
            /**
             * @description Unique identifier for this single collection preset.
             * @example 81dfa7e0-56d2-471f-b96a-1cf8a62bdf28
             */
            id: string;
            /**
             * @description The collection of the item the Comment is created for.
             * @example articles
             */
            collection: string | components["schemas"]["Collections"];
            /**
             * @description The item the Comment is created for.
             * @example 123
             */
            item: string;
            /**
             * @description User comment. This will store the comments that show up in the right sidebar of the item edit page in the admin app.
             * @example This is a comment
             */
            comment: string;
            /**
             * Format: date-time
             * @description When the Comment was created.
             * @example 2024-01-23T12:34:56Z
             */
            date_created?: string | null;
            /**
             * Format: date-time
             * @description When the Comment was updated.
             * @example 2024-01-23T12:34:56Z
             */
            date_updated?: string | null;
            /**
             * @description User that created the Comment.
             * @example 81dfa7e0-56d2-471f-b96a-1cf8a62bdf28
             */
            user_created: string | components["schemas"]["Users"];
            /**
             * @description User that updated the Comment.
             * @example 81dfa7e0-56d2-471f-b96a-1cf8a62bdf28
             */
            user_updated: string | components["schemas"]["Users"];
        };
        ItemsArtAuthors: {
            /** Format: uuid */
            id: string;
            name?: string | null;
            email?: string | null;
            user?: (string | components["schemas"]["Users"]) | null;
        };
        ItemsChat: {
            /** Format: uuid */
            id: string;
            user_created?: (string | components["schemas"]["Users"]) | null;
            /** Format: timestamp */
            date_created?: string | null;
            user?: (string | components["schemas"]["Users"]) | null;
            text?: string | null;
        };
        ItemsUsersExtra: {
            /** Format: uuid */
            id: string;
            badges?: unknown;
            user: string | components["schemas"]["Users"];
        };
        ItemsArtArticlesTranslations: {
            id: number;
            art_articles_id?: (string | components["schemas"]["ItemsArtArticles"]) | null;
            languages_code?: string | null;
            description?: string | null;
            name?: string | null;
            text?: string | null;
            block?: unknown;
        };
        ItemsArtArticles: {
            /** Format: uuid */
            id: string;
            status: string;
            sort?: number | null;
            image?: (string | components["schemas"]["Files"]) | null;
            art_id?: string | null;
            /** @description Navnet til artikkelen. Blir bare brukt om en oversettelse ikke blir funnet. */
            name?: string | null;
            /** @description Deskripsjonen til artikkelen. Blir bare brukt om en oversettelse ikke blir funnet. */
            description?: string | null;
            /** @description Teksten til artikkelen, du kan bruke markdown. Blir bare brukt om en oversettelse ikke blir funnet. */
            text?: string | null;
            author?: (string | components["schemas"]["ItemsArtAuthors"]) | null;
            tags?: unknown;
            /** Format: timestamp */
            date?: string | null;
            /** Format: timestamp */
            date_updated?: string | null;
            type?: string | null;
            translations?: (number | components["schemas"]["ItemsArtArticlesTranslations"])[] | null;
            authors?: (number | components["schemas"]["ItemsArtArticlesArtAuthors"])[] | null;
            blocks?: (number | components["schemas"]["ItemsArtArticlesBlocks"])[] | null;
        };
        ItemsBlockImage: {
            /** Format: uuid */
            id: string;
            image?: (string | components["schemas"]["Files"]) | null;
            description?: string | null;
            alt?: string | null;
        };
        ItemsBlockMarkdown: {
            /** Format: uuid */
            id: string;
            content?: string | null;
        };
        ItemsArtArticlesBlocks: {
            id: number;
            art_articles_id?: (string | components["schemas"]["ItemsArtArticles"]) | null;
            item?: (string | components["schemas"]["ItemsBlockImage"] | components["schemas"]["ItemsBlockMarkdown"])[] | null;
            sort?: number | null;
            collection?: string | null;
        };
        ItemsArtArticlesArtAuthors: {
            id: number;
            art_articles_id?: (string | components["schemas"]["ItemsArtArticles"]) | null;
            art_authors_id?: (string | components["schemas"]["ItemsArtAuthors"]) | null;
            sort?: number | null;
        };
    };
    responses: {
        /** @description Error: Not found. */
        NotFoundError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    error?: {
                        /** Format: int64 */
                        code?: number;
                        message?: string;
                    };
                };
            };
        };
        /** @description Error: Unauthorized request */
        UnauthorizedError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    error?: {
                        /** Format: int64 */
                        code?: number;
                        message?: string;
                    };
                };
            };
        };
    };
    parameters: {
        /** @description Index */
        Id: number;
        /** @description Unique identifier for the object. */
        UUId: string;
        /** @description Collection of which you want to retrieve the items from. */
        Collection: string;
        /** @description Filter by items that contain the given search query in one of their fields. */
        Search: string;
        /** @description Cursor for use in pagination. Often used in combination with limit. */
        Page: number;
        /** @description How many items to skip when fetching data. */
        Offset: number;
        /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *      */
        Sort: string[];
        /** @description What metadata to return in the response. */
        Meta: string;
        /** @description A limit on the number of objects that are returned. */
        Limit: number;
        /** @description Select items in collection by given conditions. */
        Filter: string;
        /** @description Control what fields are being returned in the object. */
        Fields: string[];
        /** @description Saves the API response to a file. Accepts one of "csv", "json", "xml", "yaml". */
        Export: "csv" | "json" | "xml" | "yaml";
        /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
         *      */
        Version: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type SchemaFiles = components['schemas']['Files'];
export type SchemaFolders = components['schemas']['Folders'];
export type SchemaRoles = components['schemas']['Roles'];
export type SchemaUsers = components['schemas']['Users'];
export type SchemaQuery = components['schemas']['Query'];
export type SchemaXMetadata = components['schemas']['x-metadata'];
export type SchemaPresets = components['schemas']['Presets'];
export type SchemaActivity = components['schemas']['Activity'];
export type SchemaRelations = components['schemas']['Relations'];
export type SchemaSettings = components['schemas']['Settings'];
export type SchemaFields = components['schemas']['Fields'];
export type SchemaCollections = components['schemas']['Collections'];
export type SchemaComments = components['schemas']['Comments'];
export type SchemaItemsArtAuthors = components['schemas']['ItemsArtAuthors'];
export type SchemaItemsChat = components['schemas']['ItemsChat'];
export type SchemaItemsUsersExtra = components['schemas']['ItemsUsersExtra'];
export type SchemaItemsArtArticlesTranslations = components['schemas']['ItemsArtArticlesTranslations'];
export type SchemaItemsArtArticles = components['schemas']['ItemsArtArticles'];
export type SchemaItemsBlockImage = components['schemas']['ItemsBlockImage'];
export type SchemaItemsBlockMarkdown = components['schemas']['ItemsBlockMarkdown'];
export type SchemaItemsArtArticlesBlocks = components['schemas']['ItemsArtArticlesBlocks'];
export type SchemaItemsArtArticlesArtAuthors = components['schemas']['ItemsArtArticlesArtAuthors'];
export type ResponseNotFoundError = components['responses']['NotFoundError'];
export type ResponseUnauthorizedError = components['responses']['UnauthorizedError'];
export type ParameterId = components['parameters']['Id'];
export type ParameterUuId = components['parameters']['UUId'];
export type ParameterCollection = components['parameters']['Collection'];
export type ParameterSearch = components['parameters']['Search'];
export type ParameterPage = components['parameters']['Page'];
export type ParameterOffset = components['parameters']['Offset'];
export type ParameterSort = components['parameters']['Sort'];
export type ParameterMeta = components['parameters']['Meta'];
export type ParameterLimit = components['parameters']['Limit'];
export type ParameterFilter = components['parameters']['Filter'];
export type ParameterFields = components['parameters']['Fields'];
export type ParameterExport = components['parameters']['Export'];
export type ParameterVersion = components['parameters']['Version'];
export type $defs = Record<string, never>;
export interface operations {
    getAsset: {
        parameters: {
            query?: {
                /** @description The key of the asset size configured in settings. */
                key?: string;
                /** @description A JSON array of image transformations */
                transforms?: string;
                /** @description Download the asset to your computer */
                download?: boolean;
            };
            header?: never;
            path: {
                /** @description The id of the file. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
            404: components["responses"]["NotFoundError"];
        };
    };
    login: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description Email address of the user you're retrieving the access token for.
                     * @example admin@example.com
                     */
                    email: string;
                    /**
                     * Format: password
                     * @description Password of the user.
                     * @example password
                     */
                    password: string;
                    /**
                     * @description Whether to retrieve the refresh token in the JSON response, or in a httpOnly cookie.
                     * @default json
                     * @enum {string}
                     */
                    mode?: "json" | "cookie" | "session";
                    /** @description The user's one-time-password (if MFA is enabled). */
                    otp?: string;
                };
            };
        };
        responses: {
            /** @description Successful authentification */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            /** @example eyJhbGciOiJI... */
                            access_token?: string;
                            /** @example 900 */
                            expires?: number;
                            /** @example yuOJkjdPXMd... */
                            refresh_token?: string;
                        };
                    };
                };
            };
        };
    };
    refresh: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description JWT access token you want to refresh. This token can't be expired.
                     * @example eyJ0eXAiOiJKV...
                     */
                    refresh_token?: string;
                    /**
                     * @description Whether to submit and retrieve the refresh token in the JSON response, or in a httpOnly cookie.
                     * @default json
                     * @enum {string}
                     */
                    mode?: "json" | "cookie" | "session";
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            /** @example eyJhbGciOiJI... */
                            access_token?: string;
                            /** @example 900 */
                            expires?: number;
                            /** @example Gy-caJMpmGTA... */
                            refresh_token?: string;
                        };
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    logout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description The refresh token to invalidate. If you have the refresh token in a cookie through /auth/login, you don't have to submit it here.
                     * @example eyJ0eXAiOiJKV...
                     */
                    refresh_token?: string;
                    /**
                     * @description Whether the refresh token is submitted in the JSON response, or in a httpOnly cookie.
                     * @enum {string}
                     */
                    mode?: "json" | "cookie" | "session";
                };
            };
        };
        responses: {
            /** @description Request successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    passwordRequest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description Email address of the user you're requesting a reset for.
                     * @example admin@example.com
                     */
                    email: string;
                };
            };
        };
        responses: {
            401: components["responses"]["UnauthorizedError"];
        };
    };
    passwordReset: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description One-time use JWT token that is used to verify the user.
                     * @example eyJ0eXAiOiJKV1Qi...
                     */
                    token: string;
                    /**
                     * Format: password
                     * @description New password for the user.
                     * @example password
                     */
                    password: string;
                };
            };
        };
        responses: {
            401: components["responses"]["UnauthorizedError"];
        };
    };
    oauth: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        public?: boolean;
                        /** @example [
                         *       "github",
                         *       "facebook"
                         *     ] */
                        data?: string[];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    oauthProvider: {
        parameters: {
            query?: {
                /** @description Where to redirect on successful login.<br/>If set the authentication details are set inside cookies otherwise a JSON is returned. */
                redirect?: string;
            };
            header?: never;
            path: {
                /** @description Key of the activated OAuth provider. */
                provider: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        public?: boolean;
                        data?: {
                            token?: string;
                        };
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    serverInfo: {
        parameters: {
            query: {
                /** @description The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in `/config/__api.json` on your server. */
                super_admin_token: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: Record<string, never>;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    ping: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/text": string;
                };
            };
        };
    };
    "hash-generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description String to hash. */
                    string: string;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example $argon2i$v=19$m=4096,t=3,p=1$pOyIa/zmRAjCVLb2f7kOyg$DasoO6LzMM+6iKfzCDq6JbsYsZWLSm33p7i9NxL9mDc */
                        data?: string;
                    };
                };
            };
        };
    };
    "hash-verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description String to hash. */
                    string: string;
                    /** @description Hash you want to verify against. */
                    hash: string;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example true */
                        data?: boolean;
                    };
                };
            };
        };
    };
    sort: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Collection identifier */
                collection: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Primary key of item to move */
                    item?: number;
                    /** @description Primary key of item where to move the current item to */
                    to?: number;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    import: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Collection identifier */
                collection: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /** Format: binary */
                    file?: string;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    export: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Collection identifier */
                collection: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description What file format to save the export to. One of csv, xml, json
                     * @enum {string}
                     */
                    format: "csv" | "xml" | "json";
                    query: components["schemas"]["Query"];
                    file: components["schemas"]["Files"];
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    "clear-cache": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    random: {
        parameters: {
            query?: {
                /** @description Length of the random string. */
                length?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example 1>M3+4oh.S */
                        data?: string;
                    };
                };
            };
        };
    };
    getRoles: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
                /** @description Cursor for use in pagination. Often used in combination with limit. */
                page?: components["parameters"]["Page"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Roles"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getRole: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Unique identifier for the object. */
                id: components["parameters"]["UUId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Roles"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getFolders: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Folders"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getFolder: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Unique identifier for the object. */
                id: components["parameters"]["UUId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Folders"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getFiles: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Files"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    createFile: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    data?: string;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Files"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    getFile: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Unique identifier for the object. */
                id: components["parameters"]["UUId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Files"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    getPresets: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description Cursor for use in pagination. Often used in combination with limit. */
                page?: components["parameters"]["Page"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Presets"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    createPreset: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description What collection this collection preset is used for.
                     * @example articles
                     */
                    collection: string;
                    /**
                     * @description Name for the bookmark. If this is set, the collection preset will be considered to be a bookmark.
                     * @example Highly rated articles
                     */
                    title?: string;
                    /**
                     * @description The unique identifier of a role in the platform. If user is null, this will be used to apply the collection preset or bookmark for all users in the role.
                     * @example null
                     */
                    role?: string;
                    /** @description What the user searched for in search/filter in the header bar. */
                    search?: string;
                    filters?: {
                        /** @example aHKLAakdVghzD */
                        key?: string;
                        /** @example rating */
                        field?: string;
                        /** @example gte */
                        operator?: string;
                        /** @example 4.5 */
                        value?: number;
                    }[];
                    /** @description Name of the view type that is used. */
                    layout?: string;
                    /** @description Layout query that's saved per layout type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters. */
                    layout_query?: string;
                    /** @description Options of the views. The properties in here are controlled by the layout. */
                    layout_options?: string;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Presets"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    deletePresets: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    updatePresets: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    keys?: string[];
                    data?: {
                        /**
                         * @description What collection this collection preset is used for.
                         * @example articles
                         */
                        collection: string;
                        /**
                         * @description Name for the bookmark. If this is set, the collection preset will be considered to be a bookmark.
                         * @example Highly rated articles
                         */
                        title?: string;
                        /**
                         * @description The unique identifier of a role in the platform. If user is null, this will be used to apply the collection preset or bookmark for all users in the role.
                         * @example null
                         */
                        role?: string;
                        /** @description What the user searched for in search/filter in the header bar. */
                        search?: string;
                        filters?: {
                            /** @example aHKLAakdVghzD */
                            key?: string;
                            /** @example rating */
                            field?: string;
                            /** @example gte */
                            operator?: string;
                            /** @example 4.5 */
                            value?: number;
                        }[];
                        /** @description Name of the view type that is used. */
                        layout?: string;
                        /** @description Layout query that's saved per layout type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters. */
                        layout_query?: string;
                        /** @description Options of the views. The properties in here are controlled by the layout. */
                        layout_options?: string;
                    };
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Presets"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    getPreset: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Index */
                id: components["parameters"]["Id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Presets"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    deletePreset: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Index */
                id: components["parameters"]["Id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    updatePreset: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Index */
                id: components["parameters"]["Id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description What collection this collection preset is used for.
                     * @example articles
                     */
                    collection: string;
                    /**
                     * @description Name for the bookmark. If this is set, the collection preset will be considered to be a bookmark.
                     * @example Highly rated articles
                     */
                    title?: string;
                    /** @description The unique identifier of a role in the platform. If user is null, this will be used to apply the collection preset or bookmark for all users in the role. */
                    role?: number;
                    /** @description What the user searched for in search/filter in the header bar. */
                    search_query?: string;
                    filters?: {
                        /** @example rating */
                        field?: string;
                        /** @example gte */
                        operator?: string;
                        /** @example 4.5 */
                        value?: number;
                    }[];
                    /** @description Name of the view type that is used. Defaults to tabular. */
                    view_type?: string;
                    /** @description View query that's saved per view type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters. */
                    view_query?: string;
                    /** @description Options of the views. The properties in here are controlled by the layout. */
                    view_options?: string;
                    /** @description Key value pair of language-translation. Can be used to translate the bookmark title in multiple languages. */
                    translation?: Record<string, never>;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Presets"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    getActivities: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Activity"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getActivity: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Index */
                id: components["parameters"]["Id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Activity"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getRelations: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
                /** @description Cursor for use in pagination. Often used in combination with limit. */
                page?: components["parameters"]["Page"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Relations"][];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getRelation: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Index */
                id: components["parameters"]["Id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Relations"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getSettings: {
        parameters: {
            query?: {
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Cursor for use in pagination. Often used in combination with limit. */
                page?: components["parameters"]["Page"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Settings"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getFields: {
        parameters: {
            query?: {
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Fields"][];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getCollectionFields: {
        parameters: {
            query?: {
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
            };
            header?: never;
            path: {
                /** @description Unique identifier of the collection the item resides in. */
                collection: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Fields"][];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getCollectionField: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Unique identifier of the collection the item resides in. */
                collection: string;
                /** @description Unique identifier of the field. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Fields"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getUsers: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Users"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    updateUsers: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Users"];
                    keys?: string[];
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Users"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    getUser: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Unique identifier for the object. */
                id: components["parameters"]["UUId"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Users"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    updateUser: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Unique identifier for the object. */
                id: components["parameters"]["UUId"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["Users"];
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: Record<string, never>;
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getMe: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Users"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    updateMe: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Users"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    updateLastUsedPageMe: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Path of the page you used last. */
                    last_page?: string;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getCollections: {
        parameters: {
            query?: {
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Collections"][];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getCollection: {
        parameters: {
            query?: {
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path: {
                /** @description Unique identifier of the collection. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Collections"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    getComments: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description Cursor for use in pagination. Often used in combination with limit. */
                page?: components["parameters"]["Page"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Comments"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    createComment: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description Which collection this collection comment is for.
                     * @example projects
                     */
                    collection: string;
                    /** @example 81dfa7e0-56d2-471f-b96a-1cf8a62bdf28 */
                    item: string;
                    /** @example A new comment */
                    comment: string;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Comments"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    deleteComments: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    updateComments: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    keys?: string[];
                    data?: {
                        /**
                         * @description Which collection this collection comment is for.
                         * @example projects
                         */
                        collection: string;
                        /** @example 81dfa7e0-56d2-471f-b96a-1cf8a62bdf28 */
                        item?: string;
                        /** @example A new comment */
                        comment?: string;
                    };
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Comments"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    getComment: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Comments"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    deleteComment: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    updateComment: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description Which collection this comment is for.
                     * @example projects
                     */
                    collection: string;
                    /** @example 81dfa7e0-56d2-471f-b96a-1cf8a62bdf28 */
                    item?: string;
                    /** @example An updated comment */
                    comment?: string;
                };
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["Comments"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsArtAuthors: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtAuthors"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsArtAuthors: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtAuthors"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsChat: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsChat"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    createItemsChat: {
        parameters: {
            query?: {
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ItemsChat"][] | components["schemas"]["ItemsChat"];
            };
        };
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsChat"][];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsChat: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsChat"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsUsersExtra: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsUsersExtra"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsUsersExtra: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsUsersExtra"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsArtArticlesTranslations: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtArticlesTranslations"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsArtArticlesTranslations: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtArticlesTranslations"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsArtArticles: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtArticles"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsArtArticles: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtArticles"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsBlockImage: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsBlockImage"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsBlockImage: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsBlockImage"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsBlockMarkdown: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsBlockMarkdown"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsBlockMarkdown: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsBlockMarkdown"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsArtArticlesBlocks: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtArticlesBlocks"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsArtArticlesBlocks: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtArticlesBlocks"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
    readItemsArtArticlesArtAuthors: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description A limit on the number of objects that are returned. */
                limit?: components["parameters"]["Limit"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description How many items to skip when fetching data. */
                offset?: components["parameters"]["Offset"];
                /** @description How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
                 *      */
                sort?: components["parameters"]["Sort"];
                /** @description Select items in collection by given conditions. */
                filter?: components["parameters"]["Filter"];
                /** @description Filter by items that contain the given search query in one of their fields. */
                search?: components["parameters"]["Search"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtArticlesArtAuthors"][];
                        meta?: components["schemas"]["x-metadata"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
        };
    };
    readSingleItemsArtArticlesArtAuthors: {
        parameters: {
            query?: {
                /** @description Control what fields are being returned in the object. */
                fields?: components["parameters"]["Fields"];
                /** @description What metadata to return in the response. */
                meta?: components["parameters"]["Meta"];
                /** @description Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
                 *      */
                version?: components["parameters"]["Version"];
            };
            header?: never;
            path: {
                /** @description Index of the item. */
                id: number | string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful request */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["ItemsArtArticlesArtAuthors"];
                    };
                };
            };
            401: components["responses"]["UnauthorizedError"];
            404: components["responses"]["NotFoundError"];
        };
    };
}
